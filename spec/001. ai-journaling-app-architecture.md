# AI Journaling App - Technical Specification

**Document ID**: 001  
**Title**: AI Journaling App Architecture & Implementation Plan  
**Date**: 2026-02-03  
**Status**: Implementation In Progress

---

## 1. EXECUTIVE SUMMARY

### 1.1 Task/Prompt Analysis

**Original Task**: Build an AI-powered journaling application for self-improvement with calendar visualization, growth tracking, and AI-generated insights using Gemma 3 27b model.

### 1.2 Core Objectives

1. **Primary Goal**: Create a journaling platform that motivates consistent writing and personal growth through AI-powered insights
2. **User Value**: Transform raw journal entries into meaningful growth metrics and actionable insights
3. **Engagement Mechanism**: Visual progress tracking (calendar heatmap) + AI-generated growth analysis to maintain motivation
4. **Privacy-First**: End-to-end encryption ensures sensitive thoughts remain private even in database

### 1.3 Why These Goals Matter

- **Self-Improvement**: Journaling is proven to improve mental health, clarity, and goal achievement
- **Consistency Challenge**: Most people quit journaling; gamification via growth metrics + heatmap increases retention
- **Insight Generation**: Raw entries are hard to review; AI analysis reveals patterns users miss
- **Trust**: Encryption ensures users feel safe being vulnerable in their writing

---

## 2. PROJECT UNDERSTANDING

### 2.1 What This Project Is

A **full-stack web application** for personal journaling with:
- **Frontend**: Mobile-responsive web interface (PWA-capable)
- **Backend**: PocketBase (Go-based BaaS) with custom business logic
- **AI Engine**: Google AI Studio integration (Gemma 3 27b - `gemma-3-27b-it`)
- **Core Flow**: Write → Encrypt → Store → AI Analysis → Growth Metrics → Visualize Progress

### 2.2 Codebase Foundation

**Template Source**: `daata_database/` (trading app backend)
- Go 1.23 + PocketBase v0.23.8
- Docker containerization
- Migration-based schema management
- Environment-based configuration
- Seeder system for development

**Required Transformation**:
- Rename module: `gemma-reader-backend` → `ai-journal-backend`
- Replace trading schema → journaling schema
- Remove market data fetchers/limit processors
- Add AI Studio integration + encryption layer
- Add growth calculation engine

### 2.3 Key Constraints

1. **AI Rate Limit**: 15,000 tokens/minute (Gemma 3 27b)
   - Impact: Must batch AI operations, implement request queuing
   - Solution: Async processing with queue system

2. **Encryption**: Client-side encryption before sending to backend
   - Impact: Cannot search/filter encrypted content on server
   - Solution: Store metadata unencrypted (date, tags), content encrypted

3. **Mobile-First**: UI must work flawlessly on phones
   - Impact: Touch-friendly, offline-capable, responsive design

---

## 3. ARCHITECTURE DESIGN

### 3.1 High-Level Architecture

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   Frontend      │────▶│  PocketBase API  │────▶│  AI Studio API  │
│  (Web/PWA)      │     │   (Go Backend)   │     │ (Gemma 3 27b)   │
│                 │     │                  │     │                 │
│ - Encryption    │     │ - Auth/Users     │     │ - Analysis      │
│ - Calendar UI   │     │ - Journal CRUD   │     │ - Insights      │
│ - Heatmap       │     │ - Async Queue    │     │ - Metrics       │
└─────────────────┘     └──────────────────┘     └─────────────────┘
         │                       │
         │                       ▼
         │              ┌──────────────────┐
         │              │   SQLite (PB)    │
         │              │                  │
         └─────────────▶│ - Encrypted      │
    Encrypted Content   │   Entries        │
                        │ - Metadata       │
                        │ - Growth Stats   │
                        └──────────────────┘
```

### 3.2 Database Schema (PocketBase Collections)

#### Collection 1: `users` (Extended)
```go
// Built-in auth fields (email, password, etc.) +
Fields:
- encryption_key_hash: string (client encryption key, server-stored hash only)
- created_entries_count: number (total journal entries)
- current_streak_days: number (consecutive writing days)
- longest_streak_days: number (record streak)
- last_entry_date: date (for streak calculation)
- preferred_analysis_frequency: select (daily/weekly/monthly)
```

#### Collection 2: `journal_entries` (Encrypted Content)
```go
Fields:
- user: relation → users (required, cascade delete)
- entry_date: date (required, the date this entry represents)
- encrypted_content: text (required, AES-256 encrypted journal content)
- content_hash: string (for integrity verification)
- mood_rating: number (1-10, optional, user self-reported)
- tags: json (array of strings, e.g., ["work", "family", "stress"])
- word_count: number (cleartext metadata)
- created: datetime (auto)
- updated: datetime (auto)

Indexes:
- idx_entries_user_date (user + entry_date) - for calendar queries
- idx_entries_user_created (user + created) - for recent entries
```

#### Collection 3: `growth_analysis` (AI-Generated)
```go
Fields:
- user: relation → users (required, cascade delete)
- analysis_type: select (daily/weekly/monthly)
- period_start: date (start of analysis period)
- period_end: date (end of analysis period)
- encrypted_insights: text (AI-generated insights, encrypted)
- growth_score: number (0-100, calculated by AI)
- key_themes: json (array of recurring topics)
- emotional_trend: select (improving/stable/declining)
- action_items: json (array of AI-suggested actions)
- motivation_quote: string (AI-selected motivational quote)
- created: datetime (auto)

Indexes:
- idx_analysis_user_period (user + analysis_type + period_start)
```

#### Collection 4: `ai_processing_queue` (Async Jobs)
```go
Fields:
- user: relation → users
- job_type: select (entry_analysis/streak_update/growth_calculation)
- entry_id: relation → journal_entries (nullable)
- status: select (pending/processing/completed/failed)
- priority: number (1-10, higher = more urgent)
- attempts: number (retry count)
- error_message: text (on failure)
- scheduled_at: datetime (when to process)
- created: datetime (auto)

Indexes:
- idx_queue_status_scheduled (status + scheduled_at) - for job polling
```

#### Collection 5: `calendar_heatmap_cache` (Performance)
```go
Fields:
- user: relation → users (required)
- year: number (e.g., 2026)
- month: number (1-12, 0 = full year view)
- data_json: json (pre-computed heatmap data)
- last_entry_id: relation → journal_entries (for cache invalidation)
- updated: datetime (auto)

Indexes:
- idx_heatmap_user_year_month (user + year + month) - unique
```

### 3.3 API Integration Strategy

#### AI Studio (Gemma 3 27b) Integration

**Rate Limit Management**:
- 15,000 tokens/minute = ~250 tokens/second
- Average journal entry: 300-500 tokens
- Average analysis request: 1000-2000 tokens
- **Strategy**: Implement token bucket algorithm with queue

**Context Management**:
1. **Entry Analysis**: Analyze single entry only (low token usage)
2. **Weekly Analysis**: Last 7 entries + previous week summary (medium usage)
3. **Monthly Analysis**: Weekly summaries only, not raw entries (high efficiency)
4. **Growth Trends**: Aggregated metrics only, no raw content (minimal usage)

**Prompt Templates** (stored in backend):

```
# Entry Analysis Prompt
Analyze this journal entry for:
1. Emotional tone (positive/negative/neutral)
2. Key themes/topics discussed
3. Growth indicators (challenges faced, lessons learned)
4. One encouraging insight

Entry: {{encrypted_content_decrypted}}

Respond in JSON format with fields: tone, themes[], growth_indicators[], insight
```

```
# Weekly Growth Analysis Prompt
Based on these daily analyses from {{start_date}} to {{end_date}}:
{{daily_summaries}}

Calculate:
1. Overall growth score (0-100)
2. Emotional trend direction
3. Recurring themes this week
4. 3 actionable suggestions for next week
5. One motivational quote that fits their journey

Respond in JSON format.
```

### 3.4 Encryption Strategy

**Client-Side Encryption (Frontend)**:
1. User creates encryption key (derived from password + salt)
2. Key stored in browser (localStorage/IndexedDB) - never sent to server
3. Before sending entry: Encrypt content with AES-256-GCM
4. Server receives: `encrypted_content` blob + metadata (date, tags, word_count)

**Backend Storage**:
- Store `encrypted_content` as-is (cannot read it)
- Store metadata in cleartext for queries (date range, tags, word_count)

**Key Management**:
- Server stores `encryption_key_hash` for verification only
- Actual encryption/decryption happens only on client
- If user loses key = data lost (no backdoor - privacy guarantee)

---

## 4. FEATURE BREAKDOWN

### 4.1 Core Features

#### F1: Journal Entry Management
**Logic**:
- Create entry with date, encrypted content, mood, tags
- Edit existing entry (only metadata + re-encrypt content)
- Delete entry (hard delete)
- View entry list (date, mood, tags - no content preview)
- View full entry (decrypt client-side after fetch)

**UI Components**:
- Entry form with rich text editor (simple, mobile-friendly)
- Mood selector (1-10 emoji scale)
- Tag input (comma-separated, autocomplete)
- Entry list view (chronological)
- Entry detail modal/view

#### F2: Calendar Visualization
**Logic**:
- Display entries on calendar grid
- Support 3 views: Daily (list), Weekly (grid), Monthly (grid)
- Click date → view entries for that date
- Visual indicators: Entry count, mood color-coding

**UI Components**:
- Calendar grid component
- View toggle (Day/Week/Month)
- Date navigator (prev/next, today button)
- Entry popover on date click

#### F3: Calendar Heatmap (GitHub-Style)
**Logic**:
- Grid showing 365 days (or configurable range)
- Color intensity based on:
  - Entry count (more entries = darker green)
  - OR Average mood (positive = green, negative = red scale)
- Legend explaining color scale
- Hover shows date + entry count + avg mood

**UI Components**:
- Heatmap grid (52 columns × 7 rows)
- Tooltip on hover
- Legend
- Toggle: color by entry count vs mood

#### F4: AI-Powered Growth Analysis
**Logic**:
- **Trigger**: New entry created OR scheduled analysis job
- **Process**:
  1. Add job to `ai_processing_queue` with priority
  2. Background worker picks up job (respect rate limits)
  3. Decrypt entry content (server-side? NO - client sends decrypted for analysis then forgets)
  4. Send to AI Studio with structured prompt
  5. Store encrypted result in `growth_analysis`
  6. Update user's growth stats

**Analysis Types**:
1. **Entry-Level**: Immediate feedback after writing (tone, themes)
2. **Daily Summary**: End-of-day reflection on all entries
3. **Weekly Report**: Growth trends, patterns, suggestions (AI-generated Sunday night)
4. **Monthly Deep-Dive**: Comprehensive growth analysis with long-term trends

**UI Components**:
- Growth dashboard (current score, trend graph)
- AI insight cards (rotating tips/motivations)
- Weekly report view (modal/page)
- Monthly analysis history

#### F5: Streak & Gamification
**Logic**:
- Calculate writing streaks (consecutive days with entries)
- Track longest streak record
- Milestone notifications (7 days, 30 days, 100 days)
- "Current Streak" display prominently

**UI Components**:
- Streak counter badge (flame icon)
- Milestone celebration modal
- Streak calendar (visual chain)

#### F6: Growth Metrics Dashboard
**Logic**:
Calculate and display:
- Total entries written
- Total words written
- Current streak
- Longest streak
- Average mood over time (line graph)
- Entry frequency heatmap (which days of week user writes most)
- Top recurring themes (tag cloud)
- Growth score trend (AI-calculated, 0-100)

**UI Components**:
- Stats cards (key metrics)
- Mood trend line chart
- Tag cloud visualization
- Growth score progress bar
- "Writing patterns" insights

### 4.2 Advanced Features (Phase 2)

#### F7: Search & Filtering
**Challenge**: Content is encrypted, cannot search server-side
**Solution**: 
- Index tags, dates, mood in cleartext (searchable)
- Full-text search: Download entries, decrypt client-side, search locally
- Filter by: date range, tags, mood range

#### F8: Export & Backup
**Logic**:
- Export all entries as encrypted JSON (backup)
- Export as PDF (decrypt client-side, generate PDF)
- Automatic cloud backup (encrypted blobs)

#### F9: Reminders & Notifications
**Logic**:
- Daily reminder to journal (configurable time)
- Streak at-risk warning (no entry by 8 PM)
- Weekly report ready notification
- Browser push notifications (PWA)

---

## 5. IMPLEMENTATION PLAN

### 5.1 Phase 1: Foundation (Week 1)

**Backend (PocketBase)**:
1. Initialize new Go module: `ai-journal-backend`
2. Set up Docker infrastructure (Dockerfile + docker-compose)
3. Create database migrations:
   - `001_initial_journal_schema.go`: users extension, journal_entries
   - `002_growth_analysis.go`: growth_analysis collection
   - `003_ai_queue.go`: ai_processing_queue
   - `004_heatmap_cache.go`: calendar_heatmap_cache
4. Implement basic hooks:
   - On entry create: add to AI queue
   - On entry delete: invalidate heatmap cache

**Frontend (Initial Setup)**:
1. Initialize web project (recommend: SvelteKit + TypeScript + Tailwind)
2. Set up PocketBase JavaScript SDK
3. Create authentication pages (login/register)
4. Implement encryption utilities (client-side AES)

### 5.2 Phase 2: Core Journal (Week 2)

**Backend**:
1. Implement entry CRUD API hooks
2. Create AI queue processor skeleton
3. Add encryption key hash verification

**Frontend**:
1. Build entry form (rich text, mood, tags)
2. Build entry list view
3. Implement client-side encryption/decryption
4. Connect to backend API

### 5.3 Phase 3: Calendar & Heatmap (Week 3)

**Backend**:
1. Create heatmap cache regeneration job
2. API endpoints: `/api/calendar/:year/:month`
3. Streak calculation logic

**Frontend**:
1. Build calendar component (Day/Week/Month views)
2. Build heatmap visualization (GitHub-style)
3. Entry popover interactions

### 5.4 Phase 4: AI Integration (Week 4)

**Backend**:
1. Implement AI Studio client (respect rate limits)
2. Create prompt templates
3. Build queue processor with token bucket
4. Implement analysis generation:
   - Entry analysis (on create)
   - Weekly report (scheduled job)
   - Growth score calculation

**Frontend**:
1. Create growth dashboard
2. Display AI insights
3. Weekly report view

### 5.5 Phase 5: Polish & Optimization (Week 5)

**Backend**:
1. Add caching for heatmap data
2. Optimize AI queue (prioritization, retry logic)
3. Add export endpoints

**Frontend**:
1. Add search/filter (client-side)
2. Add export functionality
3. PWA features (offline support, push notifications)
4. Mobile responsiveness polish

---

## 6. TECHNICAL DETAILS

### 6.1 Encryption Implementation

**Algorithm**: AES-256-GCM
**Key Derivation**: PBKDF2 (password + salt, 100k iterations)
**Client Library**: `crypto-js` or native Web Crypto API

**Flow**:
```javascript
// On user registration
const salt = crypto.randomBytes(16);
const key = pbkdf2(password, salt, 100000, 32, 'sha256');
localStorage.setItem('journal_key', key);
localStorage.setItem('journal_salt', salt);

// Before sending entry
const encrypted = aesGcmEncrypt(content, key);
fetch('/api/collections/journal_entries/records', {
  method: 'POST',
  body: JSON.stringify({
    encrypted_content: encrypted,
    entry_date: date,
    word_count: content.split(' ').length,
    tags: tags,
    mood_rating: mood
  })
});

// After receiving entry
const decrypted = aesGcmDecrypt(encrypted_content, key);
display(decrypted);
```

### 6.2 AI Rate Limiting

**Token Bucket Algorithm**:
```go
type TokenBucket struct {
    tokens    float64
    capacity  float64
    rate      float64 // tokens per second
    lastUpdate time.Time
    mu        sync.Mutex
}

// 15000 tokens/minute = 250 tokens/second
bucket := NewTokenBucket(15000, 250)

// Before AI call
if !bucket.Consume(tokensNeeded) {
    // Delay job, re-queue
    return ErrRateLimited
}
// Make API call
```

### 6.3 Queue Processing

**Job Scheduler** (Go goroutine):
```go
func StartAIQueueProcessor(app core.App) {
    ticker := time.NewTicker(5 * time.Second)
    go func() {
        for range ticker.C {
            processPendingJobs(app)
        }
    }()
}

func processPendingJobs(app core.App) {
    // Fetch pending jobs, ordered by priority + scheduled_at
    // Respect rate limits
    // Process each job
    // Update status (completed/failed)
}
```

### 6.4 Calendar Heatmap Caching

**Cache Strategy**:
- Pre-compute heatmap data on entry create/update/delete
- Store in `calendar_heatmap_cache` collection
- Invalidate when new entry added
- Frontend fetches cached JSON (fast)

---

## 7. PSEUDOCODE / LOGIC FLOW

### 7.1 Create Journal Entry Flow

```
USER ACTIONS:
1. User writes entry in form (content, date, mood, tags)
2. User clicks "Save"

FRONTEND:
3. Validate form (content not empty, date valid)
4. Derive encryption key from password + salt (cached in memory)
5. Encrypt content: encrypted = AES256GCM(content, key)
6. Calculate word_count = word_count(content)
7. POST /api/collections/journal_entries/records
   Body: {
     encrypted_content: encrypted,
     entry_date: date,
     mood_rating: mood,
     tags: tags,
     word_count: word_count
   }

BACKEND:
8. Receive request
9. Validate: user authenticated, required fields present
10. Check encryption_key_hash matches user's stored hash
11. Create record in journal_entries
12. OnAfterCreate hook:
    a. Update user's last_entry_date
    b. Recalculate streak (compare with previous entry date)
    c. Add AI job to queue: {
         type: "entry_analysis",
         entry_id: new_entry.id,
         priority: 5
       }
    d. Invalidate heatmap cache for this month/year
13. Return 201 Created

FRONTEND:
14. Receive success response
15. Show success notification
16. Clear form
17. Refresh entry list

ASYNC (Background):
18. Queue processor picks up job
19. Send decrypted content to AI Studio (wait for rate limit)
20. AI returns analysis: {tone, themes[], insight}
21. Encrypt analysis with user's key
22. Store in growth_analysis (type: "entry")
23. Mark job as completed
```

### 7.2 Weekly Growth Analysis Flow

```
SCHEDULER:
1. Cron job runs every Sunday at 11:00 PM

BACKEND:
2. For each user who has entries this week:
   a. Fetch all entries from last 7 days
   b. Aggregate: avg mood, total words, entry count
   c. Fetch entry-level analyses for context
   
3. Add AI job: {
     type: "weekly_analysis",
     user_id: user.id,
     period_start: start_of_week,
     period_end: end_of_week,
     priority: 8
   }

ASYNC:
4. Queue processor picks job
5. Build prompt with:
   - Period dates
   - Daily summaries (decrypted temporarily)
   - Previous week growth score
   
6. Send to AI Studio
7. AI returns: {
     growth_score: 0-100,
     emotional_trend: "improving",
     key_themes: ["work stress", "family time"],
     action_items: ["Practice mindfulness", "Schedule downtime"],
     motivation_quote: "Progress, not perfection..."
   }

8. Encrypt entire response
9. Store in growth_analysis (type: "weekly")
10. Update user's stats if new records (longest streak, etc.)
11. Mark job completed

NOTIFICATION:
12. Send push notification: "Weekly growth report ready!"

FRONTEND:
13. User opens app, sees notification badge
14. User clicks "Weekly Report"
15. Fetch encrypted analysis from API
16. Decrypt client-side
17. Display beautiful report with:
    - Growth score (big number)
    - Trend arrow (up/down/stable)
    - Key themes (tag pills)
    - Action items (checklist)
    - Motivational quote (banner)
```

### 7.3 Calendar Heatmap Generation

```
TRIGGER:
1. On entry create/update/delete
2. On user request (if cache miss)

BACKEND:
3. Determine affected months/years from entry_date
4. For each affected period:
   a. Query entries in period: SELECT entry_date, mood_rating, COUNT(*)
   b. Group by date
   c. Calculate color intensity per date:
      - By count: intensity = min(count / 5, 1.0) // max at 5 entries
      - By mood: color = interpolate(red(1) -> green(10))
   
5. Generate JSON structure:
   {
     "year": 2026,
     "month": 0, // 0 = full year
     "days": [
       {"date": "2026-01-01", "count": 2, "mood": 7, "color": "#4caf50"},
       ...
     ]
   }

6. Upsert into calendar_heatmap_cache

FRONTEND:
7. User navigates to heatmap view
8. GET /api/calendar_heatmap?year=2026&month=0
9. Receive cached JSON
10. Render grid:
    - 52 columns (weeks)
    - 7 rows (days)
    - Each cell colored from data
11. Add tooltips on hover
```

---

## 8. TESTING PLAN

### 8.1 Unit Tests

**Backend (Go)**:
- Encryption/decryption round-trip
- Token bucket rate limiting
- Streak calculation logic
- Date range queries

**Frontend (Jest/Vitest)**:
- AES encryption/decryption
- Form validation
- Date formatting utilities
- Heatmap data transformation

### 8.2 Integration Tests

**API Tests**:
1. Create entry → Verify in database
2. Create entry → Verify AI job queued
3. Edit entry → Verify cache invalidated
4. Delete entry → Verify streak recalculated
5. AI queue processing → Verify analysis created

**E2E Tests (Playwright)**:
1. User registration flow
2. Create journal entry
3. View entry in calendar
4. View heatmap
5. Check growth dashboard loads

### 8.3 Manual Testing Checklist

**Encryption & Privacy**:
- [ ] Entry content encrypted in network tab (no plaintext)
- [ ] Database shows encrypted blobs only
- [ ] Key lost scenario tested (should not decrypt)
- [ ] Different users cannot decrypt each other's data

**AI Integration**:
- [ ] Rate limit respected (no 429 errors)
- [ ] AI analysis generated within 5 minutes of entry
- [ ] Weekly report generated on schedule
- [ ] Growth score is reasonable (0-100 range)

**Calendar & Heatmap**:
- [ ] Calendar shows correct entries per date
- [ ] Heatmap colors match entry count/mood
- [ ] Navigation (prev/next month) works
- [ ] Mobile: swipe gestures work

**Mobile Responsiveness**:
- [ ] Test on iPhone 12/13/14/15 (Safari)
- [ ] Test on Android Chrome
- [ ] Touch targets minimum 44px
- [ ] No horizontal scroll
- [ ] PWA install prompt appears

**Performance**:
- [ ] Page load < 2s on 3G
- [ ] Heatmap renders < 100ms
- [ ] Entry list loads < 500ms (100 entries)

---

## 9. PROJECT STRUCTURE

```
ai-journaling-app/
├── backend/                          # Go + PocketBase
│   ├── main.go                       # Entry point
│   ├── go.mod                        # Module: ai-journal-backend
│   ├── go.sum
│   ├── Dockerfile
│   ├── docker-compose.yml
│   ├── entrypoint.sh
│   ├── migrations/
│   │   ├── 001_initial_journal_schema.go
│   │   ├── 002_growth_analysis.go
│   │   ├── 003_ai_queue.go
│   │   ├── 004_heatmap_cache.go
│   │   ├── seeder.go
│   │   └── ai_processor.go           # AI queue logic
│   └── hooks/                        # Custom PB hooks
│       ├── entry_hooks.go
│       └── user_hooks.go
│
├── frontend/                         # SvelteKit
│   ├── package.json
│   ├── svelte.config.js
│   ├── tailwind.config.js
│   ├── tsconfig.json
│   ├── vite.config.ts
│   ├── src/
│   │   ├── routes/                   # File-based routing
│   │   │   ├── +layout.svelte        # Root layout
│   │   │   ├── +page.svelte          # Landing page
│   │   │   ├── login/
│   │   │   │   └── +page.svelte      # Login page
│   │   │   ├── register/
│   │   │   │   └── +page.svelte      # Register page
│   │   │   ├── dashboard/
│   │   │   │   └── +page.svelte      # Dashboard
│   │   │   ├── journal/
│   │   │   │   ├── new/
│   │   │   │   │   └── +page.svelte  # New entry
│   │   │   │   └── [id]/
│   │   │   │       └── +page.svelte  # Entry detail
│   │   │   ├── calendar/
│   │   │   │   └── +page.svelte      # Calendar view
│   │   │   ├── heatmap/
│   │   │   │   └── +page.svelte      # Heatmap view
│   │   │   └── growth/
│   │   │       └── +page.svelte      # Growth dashboard
│   │   ├── lib/
│   │   │   ├── components/
│   │   │   │   ├── Calendar/
│   │   │   │   ├── Heatmap/
│   │   │   │   ├── EntryForm/
│   │   │   │   ├── EntryList/
│   │   │   │   ├── GrowthDashboard/
│   │   │   │   ├── AIInsights/
│   │   │   │   └── ui/               # UI components (shadcn-svelte)
│   │   │   ├── pocketbase.ts         # PB client
│   │   │   ├── encryption.ts         # AES encryption
│   │   │   ├── stores.ts             # Svelte stores
│   │   │   └── utils.ts              # Utilities
│   │   └── types/
│   │       ├── journal.ts
│   │       └── growth.ts
│   ├── static/
│   └── .env
│
├── spec/                             # Specifications
│   ├── 001. ai-journaling-app-architecture.md  # This file
│   └── handoff/                      # Session handoff docs
│       └── .gitkeep
│
└── README.md                         # Project overview
```

---

## 10. ENVIRONMENT CONFIGURATION

### 10.1 Backend Environment Variables (.env)

```bash
# Server
PB_HTTP=0.0.0.0:8090
PB_AUTOMIGRATE=true

# Admin
PB_ADMIN_EMAIL=admin@aijournal.app
PB_ADMIN_PASSWORD=secure_admin_pass

# AI Studio
AI_STUDIO_API_KEY=your_google_ai_studio_key
AI_STUDIO_MODEL=gemma-3-27b-it
AI_RATE_LIMIT_TOKENS=15000
AI_RATE_LIMIT_WINDOW=60  # seconds

# Features
PB_RUN_SEEDERS=false
ENABLE_AI_QUEUE=true
QUEUE_PROCESS_INTERVAL=5  # seconds

# Security
ENCRYPTION_HASH_PEPPER=random_string_for_hashing
```

### 10.2 Frontend Environment Variables (.env.local)

```bash
NEXT_PUBLIC_POCKETBASE_URL=http://localhost:8090
NEXT_PUBLIC_APP_NAME=AI Journal
```

---

## 11. DEPENDENCIES

### 11.1 Backend (Go)

```go
// go.mod
module ai-journal-backend

go 1.23

require (
    github.com/pocketbase/pocketbase v0.23.8
    github.com/joho/godotenv v1.5.1
    github.com/google/generative-ai-go v0.18.0  // AI Studio SDK
    golang.org/x/crypto v0.31.0  // For additional crypto if needed
)
```

### 11.2 Frontend (npm)

```json
{
  "dependencies": {
    "@sveltejs/kit": "^2.0.0",
    "svelte": "^4.0.0",
    "pocketbase": "^0.21.0",
    "crypto-js": "^4.2.0",
    "date-fns": "^3.0.0",
    "tailwindcss": "^3.4.0",
    "bits-ui": "latest",  // shadcn-svelte components
    "clsx": "latest",
    "tailwind-merge": "latest",
    "mode-watcher": "latest"
  }
}
```

---

## 12. RISK MITIGATION

| Risk | Impact | Mitigation |
|------|--------|------------|
| AI rate limit exceeded | Analysis delayed | Queue with retry, priority system |
| User loses encryption key | Data unrecoverable | Clear warnings, optional password hint |
| Mobile performance slow | Poor UX | Virtual scrolling, lazy loading |
| AI costs too high | Budget overrun | Token optimization, caching |
| Privacy breach | Legal/ethical issue | Client-side encryption, no server access |
| Streak calculation bug | User frustration | Extensive date math testing |

---

## 13. SUCCESS CRITERIA

1. **Functional**: All 6 core features working
2. **Privacy**: Data encrypted end-to-end, verified
3. **AI**: Analysis generates within 5 min, respects rate limits
4. **Mobile**: 90+ Lighthouse score on mobile
5. **UX**: User can create entry in < 30 seconds
6. **Retention**: Gamification features increase daily active users

---

## 14. NEXT STEPS

1. ✅ Spec approved (this document)
2. Initialize backend from `daata_database` template
3. Initialize frontend (Next.js)
4. Implement Phase 1 (Foundation)
5. Weekly handoff documents in `/spec/handoff/`

---

## 15. CHANGE LOG

| Date | Version | Changes |
|------|---------|---------|
| 2026-02-03 | 1.0 | Initial specification created |
| 2026-02-03 | 1.1 | Approved for implementation |
| 2026-02-03 | 1.2 | Changed frontend from Next.js to SvelteKit |

---

**END OF SPECIFICATION**
